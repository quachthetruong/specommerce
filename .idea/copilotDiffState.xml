<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/campaignservice/internal/core/domain/campaign/entity.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/campaignservice/internal/core/domain/campaign/entity.go" />
              <option name="originalContent" value="package campaign&#10;&#10;import &quot;time&quot;&#10;&#10;type Campaign struct {&#10;&#9;Id          int64          `json:&quot;id&quot; validate:&quot;required&quot;`&#10;&#9;Name        string         `json:&quot;name&quot; validate:&quot;required&quot;`&#10;&#9;Type        string         `json:&quot;type&quot; validate:&quot;required,oneof=iphone&quot;` // Currently only supports &quot;iphone&quot;&#10;&#9;Description string         `json:&quot;description&quot; validate:&quot;required&quot;`&#10;&#9;Policy      map[string]any `json:&quot;policy&quot; validate:&quot;required&quot;`&#10;&#9;StartTime   time.Time      `json:&quot;start_time&quot; validate:&quot;required&quot;`&#10;&#9;EndTime     time.Time      `json:&quot;end_time&quot; validate:&quot;required&quot;`&#10;&#9;CreatedAt   time.Time      `json:&quot;created_at&quot; validate:&quot;required&quot;`&#10;&#9;UpdatedAt   time.Time      `json:&quot;updated_at&quot; validate:&quot;required&quot;`&#10;}&#10;&#10;type IphoneCampaignPolicy struct {&#10;&#9;TotalReward      int64 `json:&quot;total_reward&quot; validate:&quot;required&quot;`&#10;&#9;MinOrderAmount   int64 `json:&quot;min_order_amount&quot; validate:&quot;required&quot;`&#10;&#9;MaxTrackedOrders int64 `json:&quot;max_tracked_orders&quot; validate:&quot;required&quot;`&#10;}&#10;&#10;func (c Campaign) ToIphoneCampaign() (IphoneCampaign,error) {&#10;&#9;var policy IphoneCampaignPolicy&#10;&#9;return IphoneCampaign{&#10;&#9;&#9;Id:          c.Id,&#10;&#9;&#9;Name:        c.Name,&#10;&#9;&#9;Type:        c.Type,&#10;&#9;&#9;Description: c.Description,&#10;&#9;&#9;Policy:      IphoneCampaignPolicy,&#10;&#9;&#9;StartTime:   c.StartTime,&#10;&#9;&#9;EndTime:     c.EndTime,&#10;&#9;&#9;CreatedAt:   c.CreatedAt,&#10;&#9;&#9;UpdatedAt:   c.UpdatedAt,&#10;&#9;}&#10;}&#10;type IphoneCampaign struct {&#10;&#9;Id          int64&#10;&#9;Name        string&#10;&#9;Type        string&#10;&#9;Description string&#10;&#9;Policy      IphoneCampaignPolicy&#10;&#9;StartTime   time.Time&#10;&#9;EndTime     time.Time&#10;&#9;CreatedAt   time.Time&#10;&#9;UpdatedAt   time.Time&#10;}&#10;" />
              <option name="updatedContent" value="package campaign&#10;&#10;import &quot;time&quot;&#10;&#10;type Campaign struct {&#10;&#9;Id          int64          `json:&quot;id&quot; validate:&quot;required&quot;`&#10;&#9;Name        string         `json:&quot;name&quot; validate:&quot;required&quot;`&#10;&#9;Type        string         `json:&quot;type&quot; validate:&quot;required,oneof=iphone&quot;` // Currently only supports &quot;iphone&quot;&#10;&#9;Description string         `json:&quot;description&quot; validate:&quot;required&quot;`&#10;&#9;Policy      map[string]any `json:&quot;policy&quot; validate:&quot;required&quot;`&#10;&#9;StartTime   time.Time      `json:&quot;start_time&quot; validate:&quot;required&quot;`&#10;&#9;EndTime     time.Time      `json:&quot;end_time&quot; validate:&quot;required&quot;`&#10;&#9;CreatedAt   time.Time      `json:&quot;created_at&quot; validate:&quot;required&quot;`&#10;&#9;UpdatedAt   time.Time      `json:&quot;updated_at&quot; validate:&quot;required&quot;`&#10;}&#10;&#10;type IphoneCampaignPolicy struct {&#10;&#9;TotalReward      int64 `json:&quot;total_reward&quot; validate:&quot;required&quot;`&#10;&#9;MinOrderAmount   int64 `json:&quot;min_order_amount&quot; validate:&quot;required&quot;`&#10;&#9;MaxTrackedOrders int64 `json:&quot;max_tracked_orders&quot; validate:&quot;required&quot;`&#10;}&#10;&#10;func (c Campaign) ToIphoneCampaign() (IphoneCampaign,error) {&#10;&#9;var policy IphoneCampaignPolicy&#10;&#9;return IphoneCampaign{&#10;&#9;&#9;Id:          c.Id,&#10;&#9;&#9;Name:        c.Name,&#10;&#9;&#9;Type:        c.Type,&#10;&#9;&#9;Description: c.Description,&#10;&#9;&#9;Policy:      IphoneCampaignPolicy,&#10;&#9;&#9;StartTime:   c.StartTime,&#10;&#9;&#9;EndTime:     c.EndTime,&#10;&#9;&#9;CreatedAt:   c.CreatedAt,&#10;&#9;&#9;UpdatedAt:   c.UpdatedAt,&#10;&#9;}&#10;}&#10;type IphoneCampaign struct {&#10;&#9;Id          int64&#10;&#9;Name        string&#10;&#9;Type        string&#10;&#9;Description string&#10;&#9;Policy      IphoneCampaignPolicy&#10;&#9;StartTime   time.Time&#10;&#9;EndTime     time.Time&#10;&#9;CreatedAt   time.Time&#10;&#9;UpdatedAt   time.Time&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/orderservice/internal/core/services/order/order_service.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/orderservice/internal/core/services/order/order_service.go" />
              <option name="originalContent" value="package order&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;github.com/rs/xid&quot;&#10;&#9;&quot;log/slog&quot;&#10;&#9;&quot;specommerce/orderservice/internal/core/domain/order&quot;&#10;&#9;&quot;specommerce/orderservice/internal/core/domain/payment&quot;&#10;&#9;&quot;specommerce/orderservice/internal/core/ports/primary&quot;&#10;&#9;&quot;specommerce/orderservice/internal/core/ports/secondary&quot;&#10;&#9;&quot;specommerce/orderservice/pkg/atomicity&quot;&#10;)&#10;&#10;// OrderService implements the order business logic&#10;type service struct {&#10;&#9;orderRepo         secondary.OrderRepository&#10;&#9;paymentPublisher  secondary.PaymentRepository&#10;&#9;campaignPublisher secondary.CampaignRepository&#10;&#9;atomicExecutor    atomicity.AtomicExecutor&#10;&#9;logger            *slog.Logger&#10;}&#10;&#10;// NewOrderService creates a new order service&#10;func NewOrderService(orderRepo secondary.OrderRepository, paymentPublisher secondary.PaymentRepository, atomicExecutor atomicity.AtomicExecutor,&#10;&#9;campaignPublisher secondary.CampaignRepository, logger *slog.Logger) primary.OrderService {&#10;&#9;return &amp;service{&#10;&#9;&#9;orderRepo:         orderRepo,&#10;&#9;&#9;campaignPublisher: campaignPublisher,&#10;&#9;&#9;paymentPublisher:  paymentPublisher,&#10;&#9;&#9;atomicExecutor:    atomicExecutor,&#10;&#9;&#9;logger:            logger,&#10;&#9;}&#10;}&#10;&#10;// CreateOrder creates a new order and initiates payment processing&#10;// Step 1: Create the order in the database with status Pending&#10;// Step 2: Send a payment request to the payment service&#10;// Step 3: If sending the payment request is successful, update the order status to Processing&#10;// Todo: Put all the steps in a workflow or saga pattern&#10;func (s *service) CreateOrder(ctx context.Context, input order.Order) (order.Order, error) {&#10;&#9;errTemplate := &quot;orderService CreateOrder %w&quot;&#10;&#9;var orderId xid.ID&#10;&#9;txErr := s.atomicExecutor.Execute(&#10;&#9;&#9;ctx, func(tc context.Context) error {&#10;&#9;&#9;&#9;pendingOrder, err := s.orderRepo.Create(ctx, input)&#10;&#9;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;&#9;return err&#10;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;err = s.paymentPublisher.SendPaymentRequest(ctx, payment.ProcessPaymentRequest{&#10;&#9;&#9;&#9;&#9;OrderId:     pendingOrder.Id,&#10;&#9;&#9;&#9;&#9;CustomerId:  pendingOrder.CustomerId,&#10;&#9;&#9;&#9;&#9;TotalAmount: pendingOrder.TotalAmount,&#10;&#9;&#9;&#9;})&#10;&#9;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;&#9;return err&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;orderId = pendingOrder.Id&#10;&#9;&#9;&#9;return nil&#10;&#9;&#9;},&#10;&#9;)&#10;&#9;if txErr != nil {&#10;&#9;&#9;return order.Order{}, fmt.Errorf(errTemplate, txErr)&#10;&#9;}&#10;&#9;processingOrder, err := s.orderRepo.UpdateStatusById(ctx, orderId, order.OrderStatusProcessing)&#10;&#9;if err != nil {&#10;&#9;&#9;return order.Order{}, fmt.Errorf(errTemplate, err)&#10;&#9;}&#10;&#9;return processingOrder, nil&#10;&#10;}&#10;&#10;// ProcessPaymentResponse processes the payment response from the payment service&#10;// Step 1: Check the payment status&#10;// Step 2: If the payment is successful, update the order status to Success. If the payment failed, update the order status to Failed&#10;// Step 3: If the order status is Success, send an order success event to the campaign service&#10;// Todo: Using CDC to hide the logic of campaign service from the order service&#10;func (s *service) ProcessPaymentResponse(ctx context.Context, input payment.ProcessPaymentResponse) (order.Order, error) {&#10;&#9;errTemplate := &quot;paymentService ProcessPaymentResponse %w&quot;&#10;&#9;orderResponse := order.Order{}&#10;&#9;txErr := s.atomicExecutor.Execute(&#10;&#9;&#9;ctx, func(tc context.Context) error {&#10;&#9;&#9;&#9;newStatus := order.OrderStatusSuccess&#10;&#9;&#9;&#9;if input.PaymentStatus == payment.PaymentStatusFailed {&#10;&#9;&#9;&#9;&#9;newStatus = order.OrderStatusFailed&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;updatedOrder, err := s.orderRepo.UpdateStatusById(ctx, input.OrderId, newStatus)&#10;&#9;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;&#9;return err&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;orderResponse = updatedOrder&#10;&#9;&#9;&#9;return nil&#10;&#9;&#9;},&#10;&#9;)&#10;&#9;if txErr != nil {&#10;&#9;&#9;return order.Order{}, fmt.Errorf(errTemplate, txErr)&#10;&#9;}&#10;&#9;if orderResponse.Status != order.OrderStatusSuccess {&#10;&#9;&#9;return orderResponse, nil&#10;&#9;}&#10;&#9;go func() {&#10;&#9;&#9;err := s.campaignPublisher.SendOrderSuccessEvent(ctx, orderResponse)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;s.logger.Error(&#10;&#9;&#9;&#9;&#9;&quot;failed to send order success event to campaign service&quot;,&#10;&#9;&#9;&#9;&#9;slog.String(&quot;order_id&quot;, orderResponse.Id.String()),&#10;&#9;&#9;&#9;&#9;slog.String(&quot;error&quot;, err.Error()),&#10;&#9;&#9;&#9;)&#10;&#9;&#9;}&#10;&#9;}()&#10;&#10;&#9;return orderResponse, nil&#10;}&#10;&#10;func (s *service) GetAllOrders(ctx context.Context) ([]order.Order, error) {&#10;&#9;return s.orderRepo.GetAll(ctx)&#10;}&#10;" />
              <option name="updatedContent" value="package order&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;github.com/rs/xid&quot;&#10;&#9;&quot;log/slog&quot;&#10;&#9;&quot;specommerce/orderservice/internal/core/domain/order&quot;&#10;&#9;&quot;specommerce/orderservice/internal/core/domain/payment&quot;&#10;&#9;&quot;specommerce/orderservice/internal/core/ports/primary&quot;&#10;&#9;&quot;specommerce/orderservice/internal/core/ports/secondary&quot;&#10;&#9;&quot;specommerce/orderservice/pkg/atomicity&quot;&#10;)&#10;&#10;// OrderService implements the order business logic&#10;type service struct {&#10;&#9;orderRepo         secondary.OrderRepository&#10;&#9;paymentPublisher  secondary.PaymentRepository&#10;&#9;campaignPublisher secondary.CampaignRepository&#10;&#9;atomicExecutor    atomicity.AtomicExecutor&#10;&#9;logger            *slog.Logger&#10;}&#10;&#10;// NewOrderService creates a new order service&#10;func NewOrderService(orderRepo secondary.OrderRepository, paymentPublisher secondary.PaymentRepository, atomicExecutor atomicity.AtomicExecutor,&#10;&#9;campaignPublisher secondary.CampaignRepository, logger *slog.Logger) primary.OrderService {&#10;&#9;return &amp;service{&#10;&#9;&#9;orderRepo:         orderRepo,&#10;&#9;&#9;campaignPublisher: campaignPublisher,&#10;&#9;&#9;paymentPublisher:  paymentPublisher,&#10;&#9;&#9;atomicExecutor:    atomicExecutor,&#10;&#9;&#9;logger:            logger,&#10;&#9;}&#10;}&#10;&#10;// CreateOrder creates a new order and initiates payment processing&#10;// Step 1: Create the order in the database with status Pending&#10;// Step 2: Send a payment request to the payment service&#10;// Step 3: If sending the payment request is successful, update the order status to Processing&#10;// TODO: Put all the steps in a workflow or saga pattern&#10;func (s *service) CreateOrder(ctx context.Context, input order.Order) (order.Order, error) {&#10;&#9;errTemplate := &quot;orderService CreateOrder %w&quot;&#10;&#9;var orderId xid.ID&#10;&#9;txErr := s.atomicExecutor.Execute(&#10;&#9;&#9;ctx, func(tc context.Context) error {&#10;&#9;&#9;&#9;pendingOrder, err := s.orderRepo.Create(ctx, input)&#10;&#9;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;&#9;return err&#10;&#9;&#9;&#9;}&#10;&#10;&#9;&#9;&#9;err = s.paymentPublisher.SendPaymentRequest(ctx, payment.ProcessPaymentRequest{&#10;&#9;&#9;&#9;&#9;OrderId:     pendingOrder.Id,&#10;&#9;&#9;&#9;&#9;CustomerId:  pendingOrder.CustomerId,&#10;&#9;&#9;&#9;&#9;TotalAmount: pendingOrder.TotalAmount,&#10;&#9;&#9;&#9;})&#10;&#9;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;&#9;return err&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;orderId = pendingOrder.Id&#10;&#9;&#9;&#9;return nil&#10;&#9;&#9;},&#10;&#9;)&#10;&#9;if txErr != nil {&#10;&#9;&#9;return order.Order{}, fmt.Errorf(errTemplate, txErr)&#10;&#9;}&#10;&#9;processingOrder, err := s.orderRepo.UpdateStatusById(ctx, orderId, order.OrderStatusProcessing)&#10;&#9;if err != nil {&#10;&#9;&#9;return order.Order{}, fmt.Errorf(errTemplate, err)&#10;&#9;}&#10;&#9;return processingOrder, nil&#10;&#10;}&#10;&#10;// ProcessPaymentResponse processes the payment response from the payment service&#10;// Step 1: Check the payment status&#10;// Step 2: If the payment is successful, update the order status to Success. If the payment failed, update the order status to Failed&#10;// Step 3: If the order status is Success, send an order success event to the campaign service&#10;// TODO: Use CDC to decouple the campaign service logic from the order service&#10;func (s *service) ProcessPaymentResponse(ctx context.Context, input payment.ProcessPaymentResponse) (order.Order, error) {&#10;&#9;errTemplate := &quot;paymentService ProcessPaymentResponse %w&quot;&#10;&#9;orderResponse := order.Order{}&#10;&#9;txErr := s.atomicExecutor.Execute(&#10;&#9;&#9;ctx, func(tc context.Context) error {&#10;&#9;&#9;&#9;newStatus := order.OrderStatusSuccess&#10;&#9;&#9;&#9;if input.PaymentStatus == payment.PaymentStatusFailed {&#10;&#9;&#9;&#9;&#9;newStatus = order.OrderStatusFailed&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;updatedOrder, err := s.orderRepo.UpdateStatusById(ctx, input.OrderId, newStatus)&#10;&#9;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;&#9;return err&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;orderResponse = updatedOrder&#10;&#9;&#9;&#9;return nil&#10;&#9;&#9;},&#10;&#9;)&#10;&#9;if txErr != nil {&#10;&#9;&#9;return order.Order{}, fmt.Errorf(errTemplate, txErr)&#10;&#9;}&#10;&#9;if orderResponse.Status != order.OrderStatusSuccess {&#10;&#9;&#9;return orderResponse, nil&#10;&#9;}&#10;&#9;go func() {&#10;&#9;&#9;err := s.campaignPublisher.SendOrderSuccessEvent(ctx, orderResponse)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;s.logger.Error(&#10;&#9;&#9;&#9;&#9;&quot;failed to send order success event to campaign service&quot;,&#10;&#9;&#9;&#9;&#9;slog.String(&quot;order_id&quot;, orderResponse.Id.String()),&#10;&#9;&#9;&#9;&#9;slog.String(&quot;error&quot;, err.Error()),&#10;&#9;&#9;&#9;)&#10;&#9;&#9;}&#10;&#9;}()&#10;&#10;&#9;return orderResponse, nil&#10;}&#10;&#10;func (s *service) GetAllOrders(ctx context.Context) ([]order.Order, error) {&#10;&#9;return s.orderRepo.GetAll(ctx)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>